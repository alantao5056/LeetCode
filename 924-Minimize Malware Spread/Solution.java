import java.io.PrintWriter;
import java.io.StreamTokenizer;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.InputStreamReader;
import java.util.*;

public class Solution {
  static StreamTokenizer st;
  static int N;
  static int M;

  public static void main(String[] args) throws Exception {
    // read input
    BufferedReader br = new BufferedReader(new FileReader("1.in"));
    // BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    st = new StreamTokenizer(br);
    PrintWriter pw = new PrintWriter(new File("1.out"));
    // PrintWriter pw = new PrintWriter(System.out);
    N = nextInt();
    M = nextInt();
    
    // solve
    int[][] graph = new int[N][N];
    for (int i = 0; i < N; i++) {
      for (int j = 0; j < N; j++) {
        graph[i][j] = nextInt();
      }
    }

    int[] initial = new int[M];
    for (int i = 0; i < M; i++) {
      initial[i] = nextInt();
    }

    pw.println(minMalwareSpread(graph, initial));

    br.close();
    pw.close();
  }

  private static int minMalwareSpread(int[][] graph, int[] initial) {
    int n = graph.length;
    Node[] nodes = new Node[n];
    for (int i = 0; i < n; i++) {
      nodes[i] = new Node(i);
    }

    int minRemoveIdx = Integer.MAX_VALUE;
    for (int i : initial) {
      nodes[i].infected = true;
      minRemoveIdx = Math.min(minRemoveIdx, i);
    }

    for (int i = 0; i < n; i++) {
      for (int j = 0; j < n; j++) {
        if (j == i) continue;
        if (graph[i][j] == 1) {
          nodes[i].nbs.add(nodes[j]);
        }
      }
    }

    int maxRemove = 0;

    for (int i = 0; i < n; i++) {
      if (nodes[i].visited) continue;

      // new group
      ArrayDeque<Node> q = new ArrayDeque<>();
      q.add(nodes[i]);
      nodes[i].visited = true;

      Node infected = null;
      boolean done = false;
      int size = 0;
      while (!q.isEmpty()) {
        Node cur = q.poll();
        size++;
        if (cur.infected) {
          if (infected == null) {
            infected = cur;
          } else {
            done = true;
          }
        }

        for (Node nb : cur.nbs) {
          if (!nb.visited) {
            q.add(nb);
            nb.visited = true;
          }
        }
      }

      if (!done && infected != null) {
        if (size > maxRemove) {
          maxRemove = size;
          minRemoveIdx = infected.idx;
        } else if (size == maxRemove) {
          minRemoveIdx = Math.min(minRemoveIdx, infected.idx);
        }
      }
    }

    return minRemoveIdx;
  }

  private static class Node {
    List<Node> nbs = new ArrayList<>();
    boolean infected;
    boolean visited = false;
    int idx;
    public Node(int idx) {
      this.idx = idx;
    }
  }

  private static int nextInt() throws Exception {
    st.nextToken();
    return (int) st.nval;
  }

  private static String nextString() throws Exception {
    st.nextToken();
    return st.sval;
  }
}